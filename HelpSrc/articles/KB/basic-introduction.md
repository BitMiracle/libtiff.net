This article describes some basic stuff about LibTiff.Net

Error Handling
--------------

LibTiff.Net handles most errors by returning an invalid/erroneous value when returning from a function call. Various diagnostic messages may also be generated by the library. All error and warning messages are directed to a single global error handler object that can be specified with a call to <xref:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)>.

Basic File Handling
-------------------

The library (like libtiff) is modeled after the normal stdio library. For example, to read from an existing TIFF image the file must first be opened: 

```cs
Tiff image = Tiff.Open("foo.tif", "r")
// ... do stuff ...
image.Close(); // or image.Dispose();
```

To create or overwrite a TIFF image the file is also opened, but with a "w" argument: 

```cs
Tiff image = Tiff.Open("foo.tif", "w")
// ... do stuff ...
image.Close(); // or image.Dispose();
```

If the file already exists it is first truncated to zero length. 

---

**Note**

TIFF image files may not be opened for both reading and writing by LibTiff.Net; there is no support for altering the contents of a TIFF file. 
 
---

LibTiff.Net buffers much information associated with writing a valid TIFF image. You should dispose all <xref:BitMiracle.LibTiff.Classic.Tiff> objects. When writing a TIFF image it is especcialy important. You can also call <xref:BitMiracle.LibTiff.Classic.Tiff.Close> at any time to close image (note that image is automatically closed during disposal). You can flush buffered data at any time using <xref:BitMiracle.LibTiff.Classic.Tiff.Flush>.

TIFF Directories
----------------

TIFF supports the storage of multiple images in a single file. Each image has an associated data structure termed a directory that houses all the information about the format and content of the image data. Images in a file are usually related but they do not need to be; it is perfectly alright to store a color image together with a black and white image. Note however that while images may be related their directories are not. That is, each directory stands on its own; their is no need to read an unrelated directory in order to properly interpret the contents of an image. 

LibTiff.Net provides several routines for reading and writing directories. In normal use there is no need to explicitly read or write a directory: the library automatically reads the first directory in a file when opened for reading, and directory information to be written is automatically accumulated and written when writing (assuming <xref:BitMiracle.LibTiff.Classic.Tiff.Dispose>, <xref:BitMiracle.LibTiff.Classic.Tiff.Close> or <xref:BitMiracle.LibTiff.Classic.Tiff.Flush> are called). 

For a file open for reading the <xref:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)> method can be used to select an arbitrary directory; directories are referenced by number with the numbering starting at 0. Otherwise the <xref:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory> and <xref:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory> methods can be used for sequential access to directories. For example, to count the number of directories in a file the following code might be used: 

```cs
using BitMiracle.LibTiff.Classic;

namespace CountTiffDirectories
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                int dircount = 0;
                do
                {
                    dircount++;
                } while (image.ReadDirectory());

                System.Console.Out.WriteLine("{0} directories in {1}", dircount, args[0]);
            }
        }
    }
}
```

Finally, note that there are couple of methods for querying the directory status of an open file: <xref:BitMiracle.LibTiff.Classic.Tiff.CurrentDirectory> and <xref:BitMiracle.LibTiff.Classic.Tiff.LastDirectory>.

There is also <xref:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory*> that can be called to print a formatted description of the contents of the current directory. 

TIFF Tags
---------

Image-related information such as the image width and height, number of samples, orientation, colorimetric information, etc. are stored in each image directory in fields or tags. Tags are identified by a number that is usually a value registered with the Aldus (now Adobe) Corporation. LibTiff.Net uses <xref:BitMiracle.LibTiff.Classic.TiffTag> enumeration instead of numbers to make code much more readable and understandable. Beware however that some vendors write TIFF images with tags that are unregistered; in this case interpreting their contents is usually a waste of time. 

LibTiff.Net reads the contents of a directory all at once and converts the on-disk information to an appropriate in-memory form. While the TIFF specification permits an arbitrary set of tags to be defined and used in a file, the library only understands a limited set of tags. Any unknown tags that are encountered in a file are ignored. There is a mechanism to extend the set of tags the library handles without modifying the library itself; this is described in [Adding new (custom) tags](~/articles/KB/adding-new-tags.html) article. 

LibTiff.Net provides two methods for getting and setting tag values: <xref:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)> and <xref:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])>. The GetField method returns array of <xref:BitMiracle.LibTiff.Classic.FieldValue> objects. The array has length equal to number of tag values. If the array is null then tag is not defined in the directory. The SetField method accepts variable number of tag values as arguments. The TIFF specification defines default values for some tags. To get the value of a tag, or its default value if it is undefined, the <xref:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)> method may be used. 

You may want to consult ["Well-known tags and their value(s) data types"](~/articles/KB/well-known-tags.html) to become familiar with exact data types and calling conventions required for each tag supported by the library. 

TIFF Compression Schemes
------------------------

LibTiff.Net includes support for a wide variety of data compression schemes. In normal operation a compression scheme is automatically used when the <xref:BitMiracle.LibTiff.Classic.TiffTag>.COMPRESSION tag is set, either by opening a file for reading, or by setting the tag when writing. 

Compression schemes are implemented by software modules termed codecs that implement decoder and encoder methods that hook into the core library i/o support. Codecs other than those bundled with the library can be registered for use with the <xref:BitMiracle.LibTiff.Classic.Tiff.RegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)> method. This method can also be used to override the core-library implementation for a compression scheme. 

Byte Order
----------

The TIFF specification says, and has always said, that a correct TIFF reader must handle images in big-endian and little-endian byte order. LibTiff.Net conforms in this respect. Consequently there is no means to force a specific byte order for the data written to a TIFF image file (data is written in the native order of the host CPU unless appending to an existing file, in which case it is written in the byte order specified in the file). 

Data Placement
--------------

The TIFF specification requires that all information except an 8-byte header can be placed anywhere in a file. In particular, it is perfectly legitimate for directory information to be written after the image data itself. Software that require that data be organized in a file in a particular order (e.g. directory information before image data) does not correctly support TIFF. LibTiff.Net provides no mechanism for controlling the placement of data in a file; image data is typically written before directory information. 

RGBA Image Support
------------------

LibTiff.Net provides a high-level interface for reading image data from a TIFF file. This interface handles the details of data organization and format for a wide variety of TIFF files; at least the large majority of those files that one would normally encounter. Image data is, by default, returned as ABGR pixels packed into 32-bit words (8 bits per sample). Rectangular rasters can be read or data can be intercepted at an intermediate level and packed into memory in a format more suitable to the application. The library handles all the details of the format of data stored on disk and, in most cases, if any colorspace conversions are required: bilevel to RGB, greyscale to RGB, CMYK to RGB, YCbCr to RGB, 16-bit samples to 8-bit samples, associated/unassociated alpha, etc. 

There are two ways to read image data using this interface. If all the data is to be stored in memory and manipulated at once, then the <xref:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage*> or <xref:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented*> can be used: 

```cs
using BitMiracle.LibTiff.Classic;

namespace UsingReadRgbaImage
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                FieldValue[] value = image.GetField(TiffTag.IMAGEWIDTH);
                int width = value[0].ToInt();

                value = image.GetField(TiffTag.IMAGELENGTH);
                int height = value[0].ToInt();

                int imageSize = height * width;
                int[] raster = new int[imageSize];

                if (image.ReadRGBAImage(width, height, raster))
                {
                    // ...process raster data...
                }

                image.Close();
            }
        }
    }
}
```

Alternatively, <xref:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage*> can be replaced with a more low-level interface that permits an application to have more control over this reading procedure. The equivalent to the above is: 

```cs
using BitMiracle.LibTiff.Classic;

namespace UsingTiffRgbaImage
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff tif = Tiff.Open(args[0], "r"))
            {
                if (tif == null)
                    return;

                string errorMsg;
                TiffRgbaImage img = TiffRgbaImage.Create(tif, false, out errorMsg);
                if (img == null)
                {
                    System.Console.Error.WriteLine(errorMsg);
                    return;
                }

                int rasterSize = img.Width * img.Height;
                int[] raster = new int[rasterSize];
                if (img.GetRaster(raster, 0, img.Width, img.Height))
                {
                    // ...process raster data...
                }
            }
        }
    }
}
```

However this usage does not take advantage of the more fine-grained control that's possible. That is, by using this interface it is possible to: 
* repeatedly fetch (and manipulate) an image without opening and closing the file 
* interpose a method for packing raster pixel data according to application-specific needs (or write the data at all) 
* interpose methods that handle TIFF formats that are not already handled by the core library 

The first item means that, for example, image viewers that want to handle multiple files can cache decoding information in order to speedup the work required to display a TIFF image. 

The second item is the main reason for this interface. By interposing a <xref:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig> and <xref:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate> (the methods that are called to pack pixel data in the raster) it is possible share the core logic that understands how to deal with TIFF while packing the resultant pixels in a format that is optimized for the application. This alternate format might be very different than the 8-bit per sample ABGR format the library writes by default. For example, if the application is going to display the image on an 8-bit colormap display the put routine might take the data and convert it on-the-fly to the best colormap indices for display. 

The last item permits an application to extend the library without modifying the core code. By overriding the code provided an application might add support for some esoteric flavor of TIFF that it needs, or it might substitute a packing routine that is able to do optimizations using application/environment-specific information. 

Scanline-based Image I/O
------------------------

The simplest interface provided by LibTiff.Net is a scanline-oriented interface that can be used to read TIFF images that have their image data organized in strips (trying to use this interface to read data written in tiles will produce errors.) A scanline is a one pixel high row of image data whose width is the width of the image. Data is returned packed if the image data is stored with samples packed together, or as arrays of separate samples if the data is stored with samples separated. The major limitation of the scanline-oriented interface, other than the need to first identify an existing file as having a suitable organization, is that random access to individual scanlines can only be provided when data is not stored in a compressed format, or when the number of rows in a strip of image data is set to one (<xref:BitMiracle.LibTiff.Classic.TiffTag>.ROWSPERSTRIP is one). 

Two methods are provided for scanline-based i/o: <xref:BitMiracle.LibTiff.Classic.Tiff.ReadScanline*> and <xref:BitMiracle.LibTiff.Classic.Tiff.WriteScanline*>. For example, to read the contents of a file that is assumed to be organized in strips, the following might be used: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadScanlines
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                FieldValue[] value = image.GetField(TiffTag.IMAGELENGTH);
                int imageLength = value[0].ToInt();

                byte[] buf = new byte[image.ScanlineSize()];
                for (int row = 0; row < imageLength; row++)
                    image.ReadScanline(buf, row);
            }
        }
    }
}
```

<xref:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize> returns the number of bytes in a decoded scanline, as returned by <xref:BitMiracle.LibTiff.Classic.Tiff.ReadScanline*>. Note however that if the file had been create with samples written in separate planes, then the above code would only read data that contained the first sample of each pixel; to handle either case one might use the following instead: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadSeparatedScanlines
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                FieldValue[] value = image.GetField(TiffTag.IMAGELENGTH);
                int imageLength = value[0].ToInt();

                value = image.GetField(TiffTag.PLANARCONFIG);
                PlanarConfig config = (PlanarConfig)value[0].ToInt();

                byte[] buf = new byte[image.ScanlineSize()];

                if (config == PlanarConfig.CONTIG)
                {
                    for (int row = 0; row < imageLength; row++)
                        image.ReadScanline(buf, row);
                }
                else if (config == PlanarConfig.SEPARATE)
                {
                    value = image.GetField(TiffTag.SAMPLESPERPIXEL);
                    short spp = value[0].ToShort();

                    for (short s = 0; s < spp; s++)
                    {
                        for (int row = 0; row < imageLength; row++)
                            image.ReadScanline(buf, row, s);
                    }
                }
            }
        }
    }
}
```

Beware however that if the following code were used instead to read data in the case config == PlanarConfig.SEPARATE,... 

```cs
for (int row = 0; row < imageLength; row++)
{
    for (short s = 0; s < spp; s++)
        image.ReadScanline(buf, row, s);
}
```

...then problems would arise if TiffTag.ROWSPERSTRIP was not one because the order in which scanlines are requested would require random access to data within strips (something that is not supported by the library when strips are compressed). 

Strip-oriented Image I/O
------------------------

The strip-oriented interfaces provided by the library provide access to entire strips of data. Unlike the scanline-oriented calls, data can be read or written compressed or uncompressed. Accessing data at a strip (or tile) level is often desirable because there are no complications with regard to random access to data within strips. 

A simple example of reading an image by strips is: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadStrips
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                byte[] buf = new byte[image.StripSize()];
                for (int strip = 0; strip < image.NumberOfStrips(); strip++)
                    image.ReadEncodedStrip(strip, buf, 0, -1);
            }
        }
    }
}
```

Notice how a strip size of -1 is used; <xref:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)> will calculate the appropriate size in this case. 

The above code reads strips in the order in which the data is physically stored in the file. If multiple samples are present and data is stored with <xref:BitMiracle.LibTiff.Classic.PlanarConfig>.SEPARATE then all the strips of data holding the first sample will be read, followed by strips for the second sample, etc. 

Finally, note that the last strip of data in an image may have fewer rows in it than specified by the TiffTag.ROWSPERSTRIP. A reader should not assume that each decoded strip contains a full set of rows in it. 

The following is an example of how to read raw strips of data from a file: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadRawStrips
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                FieldValue[] value = image.GetField(TiffTag.STRIPBYTECOUNTS);
                int[] byteCounts = value[0].ToIntArray();
                int stripSize = byteCounts[0];

                byte[] buf = new byte[stripSize];
                for (int strip = 0; strip < image.NumberOfStrips(); strip++)
                {
                    if (byteCounts[strip] > stripSize)
                    {
                        stripSize = byteCounts[strip];
                        buf = new byte[stripSize];
                    }

                    image.ReadRawStrip(strip, buf, 0, stripSize);
                }
            }
        }
    }
}
```

As above the strips are read in the order in which they are physically stored in the file; this may be different from the logical ordering expected by an application. 

Tile-oriented Image I/O
-----------------------

Tiles of data may be read and written in a manner similar to strips. With this interface, an image is broken up into a set of rectangular areas that may have dimensions less than the image width and height. All the tiles in an image have the same size, and the tile width and length must each be a multiple of 16 pixels. Tiles are ordered left-to-right and top-to-bottom in an image. As for scanlines, samples can be packed contiguously or separately. When separated, all the tiles for a sample are colocated in the file. That is, all the tiles for sample 0 appear before the tiles for sample 1, etc. 

Tiles and strips may also be extended in a z dimension to form volumes. Data volumes are organized as "slices". That is, all the data for a slice is colocated. Volumes whose data is organized in tiles can also have a tile depth so that data can be organized in cubes. 

There are actually two interfaces for tiles. One interface is similar to scanlines, to read a tiled image, code of the following sort might be used: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadTiles
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                FieldValue[] value = image.GetField(TiffTag.IMAGEWIDTH);
                int imageWidth = value[0].ToInt();

                value = image.GetField(TiffTag.IMAGELENGTH);
                int imageLength = value[0].ToInt();

                value = image.GetField(TiffTag.TILEWIDTH);
                int tileWidth = value[0].ToInt();

                value = image.GetField(TiffTag.TILELENGTH);
                int tileLength = value[0].ToInt();

                byte[] buf = new byte[image.TileSize()];
                for (int y = 0; y < imageLength; y += tileLength)
                {
                    for (int x = 0; x < imageWidth; x += tileWidth)
                        image.ReadTile(buf, 0, x, y, 0, 0);
                }
            }
        }
    }
}
```

(once again, we assume samples are packed contiguously). 

Alternatively a direct interface to the low-level data is provided a la strips. Tiles can be read with <xref:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)> or <xref:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)>, and written with <xref:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile*> or <xref:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile*>. For example, to read all the tiles in an image: 

```cs
using BitMiracle.LibTiff.Classic;

namespace ReadEncodedTile
{
    class Program
    {
        static void Main(string[] args)
        {
            using (Tiff image = Tiff.Open(args[0], "r"))
            {
                if (image == null)
                    return;

                byte[] buf = new byte[image.TileSize()];
                for (int tile = 0; tile < image.NumberOfTiles(); tile++)
                    image.ReadEncodedTile(tile, buf, 0, -1);
            }
        }
    }
}
```